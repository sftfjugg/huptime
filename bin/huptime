#!/usr/bin/env python
#
# Copyright 2013 Adin Scannell <adin@scannell.ca>, all rights reserved.
#
# This file is part of Huptime.
#
# Huptime is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Huptime is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Huptime.  If not, see <http://www.gnu.org/licenses/>.
#

import os
import sys
import signal
import re
import copy
import time
import ctypes
import argparse
import logging

from functools import partial

REALPATH = os.path.realpath(sys.argv[0])
BINDIR = os.path.dirname(REALPATH)
BASEDIR = os.path.dirname(BINDIR)
LIBDIR = os.path.join(BASEDIR, "lib", "huptime")
SOFILE = os.path.join(LIBDIR, "huptime.so")

# The version (injected by the build).
VERSION = "@(VERSION)"

# Defaults.
STOP_TIMEOUT = 10.0
MULTI_COUNT = 1

# Setup logging.
logging.basicConfig(
    level=logging.INFO,
    format="%(module)s %(process)d: %(message)s")
logger = logging.getLogger()

# Configure the command line parser.
description = "Huptime is a tool for achieving zero downtime restarts."
epilog = """
Huptime is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warrant of
MERCHANTABILITY or FITNESS FOR PARTICULAR PURPOSE. See the
GNU General Public License for more details.
"""
parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=description,
        epilog=epilog)

# Parser types.
def positive(typefn, value):
    ivalue = typefn(value)
    if ivalue < 0:
        raise argparse.ArgumentTypeError("{0} is negative".format(ivalue))
    return ivalue

# Miscellaneous arguments.
parser.add_argument('-d', '--debug', action='store_true',
        help='print debug output to stderr')
parser.add_argument('--version', action='version',
        version='%(prog)s ' + VERSION,
        help='output version information and exit')

# Mode arguments.
mutex_group = parser.add_mutually_exclusive_group()
mutex_group.add_argument('--fork', action='store_true',
        help='run using fork mode (default)')
mutex_group.add_argument('--exec', action='store_true',
        dest='mexec', help='run using exec mode')
mutex_group.add_argument('--status', action='store_true',
        help='check whether a process is still running')
mutex_group.add_argument('--restart', action='store_true',
        help='send a SIGHUP signal to a running process')
mutex_group.add_argument('--stop', action='store_true',
        help='send a SIGTERM signal to a running process')

# Other arguments.
parser.add_argument('--revive', action='store_true',
        help='restart the process on exit')
parser.add_argument('--wait', action='store_true',
        help='wait for child processes to finish')
parser.add_argument('--multi', metavar='N',
        type=partial(positive, int), default=None,
        help='run N processes and wait for exit')
parser.add_argument('--unlink', metavar='FILE', default='',
        help='unlink the given file on restart')
parser.add_argument('--timeout', type=partial(positive, float),
        default=STOP_TIMEOUT, metavar='T',
        help='timeout between TERM and KILL')
parser.add_argument('command', nargs=argparse.REMAINDER,
        help='the command to be executed')

# Parse all options.
ARGS = parser.parse_args()
ARGS.mode = 'fork' if ARGS.fork else ('exec' if ARGS.mexec else 'fork')
if ARGS.debug:
    logger.setLevel(logging.DEBUG)

if not ARGS.command:
    parser.print_help()
    sys.exit(1)

if ARGS.status or ARGS.restart or ARGS.stop:

    # Go through /proc/*/cmdline and find matches.
    # NOTE: Some interpretors may fudge the command
    # line, so we may it against argv[0:] or argv[1:].
    exact_matches = []
    inter_matches = []

    for pid in os.listdir("/proc"):
        try:
            pid = int(pid)
            if pid == os.getpid():
                continue

            cmd = open("/proc/%d/cmdline" % pid, 'r').read().split("\0")

            # An exact match.
            if (len(cmd) >= len(ARGS.command) and
                cmd[:len(ARGS.command)] == ARGS.command):
                exact_matches.append(pid)

            # Interpreter match.
            elif ((len(cmd) >= 1+len(ARGS.command) and
                   cmd[1:1+len(ARGS.command)] == ARGS.command) or
                 (len(cmd) >= 2+len(ARGS.command) and
                  cmd[2:2+len(ARGS.command)] == ARGS.command)):
                inter_matches.append(pid)
        except KeyboardInterrupt:
            sys.exit(1)
        except:
            continue

    if exact_matches:
        logger.debug("Found exact processes: %s" % exact_matches)
    if inter_matches:
        logger.debug("Found interpreter processes: %s" % inter_matches)

    # Kill the preferred process group in order
    # to do the restart. We grab the pids to block
    # until the restart is complete below.
    active_pids = []
    if exact_matches:
        active_pids = exact_matches
    elif inter_matches:
        active_pids = inter_matches
    else:
        logger.info('No process found?')
        sys.exit(1)

    for pid in active_pids:
        try:
            if ARGS.status:
                print pid
            elif ARGS.restart:
                logger.debug("Restarting PID %d..." % pid)
                os.kill(pid, signal.SIGHUP)
            elif ARGS.stop:
                logger.debug("Killing PID %d (TERM)..." % pid)
                os.kill(pid, signal.SIGTERM)
        except OSError:
            continue

    # Nothing more to do.
    if ARGS.status:
        sys.exit(0)

    # Block until the SIGHUP signal has been
    # unmasked from this PID, or it no longer
    # exists. When the SIGHUP signal is unmasked,
    # know that the restart has been processed.
    for pid in active_pids:
        start_time = time.time()
        while True:
            try:
                data = open("/proc/%d/status" % pid, 'r').read().split("\n")
                if ARGS.restart:
                    is_restarted = False
                    for line in data:
                        m = re.match("SigBlk:\s*([0-9a-f]+)", line)
                        if m:
                            # SIGHUP happens to be 1. So if
                            # this is not blocked, the number
                            # will be even. Once the signal is
                            # not blocked, we know it's done.
                            if int(m.group(1), 16) % 2 == 0:
                                is_restarted = True
                                break
                    if is_restarted:
                        break
                elif ARGS.stop:
                    now = time.time()
                    if now - start_time > ARGS.timeout:
                        logger.debug("Killing PID %d (KILL)..." % pid)
                        os.kill(pid, signal.SIGKILL)
                        start_time = now
            except KeyboardInterrupt:
                sys.exit(1)
            except:
                break
        logger.debug("Restart complete for PID %d." % pid)

else:
    logger.debug("Mode is %s." % ARGS.mode)
    logger.debug("Unlink is %s." % ARGS.unlink)
    logger.debug("Multi is %s." % ARGS.multi)
    logger.debug("Revive is %s." % ARGS.revive)

    ENV = copy.copy(os.environ)
    ENV["LD_PRELOAD"] = SOFILE
    ENV["HUPTIME_DEBUG"] = str(ARGS.debug).lower()
    ENV["HUPTIME_MODE"] = ARGS.mode
    ENV["HUPTIME_UNLINK"] = ARGS.unlink
    ENV["HUPTIME_MULTI"] = 'true' if ARGS.multi is not None else 'false'
    ENV["HUPTIME_REVIVE"] = str(ARGS.revive).lower()
    ENV["HUPTIME_WAIT"] = str(ARGS.wait).lower()

    def do_exec():
        try:
            os.execvpe(ARGS.command[0], ARGS.command, ENV)
        except Exception as e:
            logger.error(str(e))
            if ARGS.debug:
                logger.exception('Error while launching a new process')
        sys.exit(1)

    if ARGS.multi is None:
        # Execute our new process.
        do_exec()

    else:
        # Execute many processes.
        # NOTE: In this case, to ensure that
        # this can cleanly be used from supervisors
        # and init scripts, we wait for the children
        # to complete.
        child_pids = []
        for _ in range(ARGS.multi):
            parent_pid = os.getpid()
            pid = os.fork()
            if pid == 0:
                # We setup a safe procedure here to ensure that the
                # child will receive a SIGTERM when the parent exits.
                libc = ctypes.CDLL("libc.so.6")
                if libc:
                    # Setup the signal for the parent dying.
                    libc.prctl(1, signal.SIGTERM)

                    # Check for a race condition. It's possible
                    # that the parent died between the fork() and
                    # the prtctl() above; we need to handle that.
                    if os.getppid() != parent_pid:
                        sys.exit(1)

                do_exec()
            else:
                child_pids.append(pid)

        for pid in child_pids:
            os.waitpid(pid, 0)
